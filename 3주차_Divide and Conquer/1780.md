# 종이의 개수

## 문제 이해
조금 더 어려운 쿼드 트리. 쿼드 트리의 9분할 버전.

|생각한 구현 방법|설명|시간 복잡도|
|분할과 정복, 재귀|숫자가 모두 같은지 확인하고 아니라면 9분할하며 재귀적으로 확인한다.|O(N^2)?|
|-|-|-|

## 코드
```
n = int(input())

mtrx = []

for _ in range(n):
  mtrx.append(list(map(int,input().split())))

// 딕셔너리로 0, 1, -1 개수를 센다.
cnt = dict()
cnt[0] = 0
cnt[1] = 0
cnt[-1] = 0

// 종이가 모두 같은지 확인하고, 같다면 숫자를 세고 아니면 종이를 자른다
def check(arr):
  // 초깃값
  tmp = arr[0][0]
  for i in arr:
    for j in i:
      if j != tmp:
        return cut(arr)
  cnt[tmp] += 1

// 종이를 잘라야 한다
def cut(m):
  l = len(m)
  // base case :  종이가 한장 남았다
  if l == 1:
    cnt[m[0][0]] += 1
    return
    
  // 종이를 9등분!
  m1, m2, m3, m4, m5, m6, m7, m8, m9 = [], [], [], [], [], [], [], [], []
  for i in range(0, l//3):
    m1.append(m[i][:l//3])
  for i in range(0, l//3):
    m2.append(m[i][l//3:l//3*2])
  for i in range(0, l//3):
    m3.append(m[i][l//3*2:])
  for i in range(l//3, l//3*2):
    m4.append(m[i][:l//3])
  for i in range(l//3, l//3*2):
    m5.append(m[i][l//3:l//3*2])
  for i in range(l//3, l//3*2):
    m6.append(m[i][l//3*2:])
  for i in range(l//3*2, l):
    m7.append(m[i][:l//3])
  for i in range(l//3*2, l):
    m8.append(m[i][l//3:l//3*2])
  for i in range(l//3*2, l):
    m9.append(m[i][l//3*2:])
  
  // 9개의 종이에 대해 체크한다.
  check(m1)
  check(m2)
  check(m3)
  check(m4)
  check(m5)
  check(m6)
  check(m7)
  check(m8)
  check(m9)

// 
check(mtrx)

// 각각의 개수 출력
print(cnt[-1])
print(cnt[0])
print(cnt[1])
```
